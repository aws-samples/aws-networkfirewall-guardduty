# Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# MIT No Attribution
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

AWSTemplateFormatVersion: "2010-09-09"
Description: "Example of using AWS Network Firewall for automatic blocking of suspicious traffic detected by GuardDuty. "

Parameters:
  Retention:
    Description: How long to retain IP addresses in the blocklist (in minutes). Default is 12 hours, minimum is 5 minutes and maximum one week (10080 minutes)
    Type: Number
    Default: 720
    MinValue: 5
    MaxValue: 10080
    ConstraintDescription: Minimum of 5 minutes and maximum of 10080 (one week).
  AdminEmail:
    Description: Email address to receive notifications. Must be a valid email address.
    Type: String
    AllowedPattern: ^(?:[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$
  ExistingRuleGroup:
    Type: String
    Default: 'False'
    Description: Name of existing Rule Group. Enter if there is an existing AWS Network Firewall rulegroup to use. This must be in region. Leave set to False for creation of new rule group.
  RulegroupPriority:
    Description: Priority for rules created by this solution within AWS Network Firewall's Rule Group.  
    Type: Number
    Default: 30000
    MinValue: 1
    MaxValue: 65535
    ConstraintDescription: Valid Range - minimum value of 1, maximum value of 65535
  RulegroupCapacity:
    Description: Capacity for a created rule group.  Each block rule takes 2 units of capacity.  Only used if creating a new rule grop (ExistingRuleGroup=False).
    Type: Number
    Default: 2000
    MinValue: 100
    MaxValue: 10000
    ConstraintDescription: Valid Range - minimum value of 100, maximum value of 10000.  
  PruningFrequency:
    Description: How often (how many minutes apart) the pruning check gets executed.  The default is every 15 minutes.
    Type: Number
    Default: 15
    MinValue: 5
    MaxValue: 180
    ConstraintDescription: Valid Range - minimum value of 5, maximum value of 180.  
  ArtifactsBucket:
    Description: S3 bucket with artifact files (Lambda layer)
    Type: String
    Default: awsiammedia
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$
    ConstraintDescription: ArtifactsBucket S3 bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-).
  ArtifactsPrefix:
    Description: Path in the S3 bucket containing artifact files
    Type: String
    Default: public/sample/
    AllowedPattern: ^[0-9a-zA-Z-/]*$


Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: GuardDuty to Network Firewall Configuration
      Parameters:
      - AdminEmail
      - ExistingRuleGroup
      - RulegroupCapacity
      - RulegroupPriority
      - Retention
      - PruningFrequency
    - Label:
        default: Artifact Configuration
      Parameters:
      - ArtifactsBucket
      - ArtifactsPrefix

    ParameterLabels:
      AdminEmail:
        default: Notification email (REQUIRED)
      Retention:
        default: Retention time in minutes
      ArtifactsBucket:
        default: S3 bucket for artifacts
      ArtifactsPrefix:
        default: S3 path to artifacts

Conditions:
  # Create rule group or use existing?
  CreateRulegroup: !Equals [!Ref ExistingRuleGroup, 'False' ]


Resources:

  ##########################################################################
  #                                                                        #
  # Common Resources Section                                               #
  #                                                                        #
  ##########################################################################


  #AWS Network Firewall Rule Group that will be managed by this solution.  
  #This Rule Group can be used across multiple Network Firewall Policies
  GuardDutytoFirewallRulegroup:
    Condition: CreateRulegroup
    Type: 'AWS::NetworkFirewall::RuleGroup'
    Properties:
      RuleGroupName: !Join ["-" , [!Ref 'AWS::StackName', BlockList]]
      Type: STATELESS
      Capacity: !Ref RulegroupCapacity
      Description: Rulegroup managed by GuardDuty-to-NetworkFirewall solution
      Tags:
        - Key: ManagedBy
          Value: GuardDutytoFirewallSolution
      RuleGroup:
        RulesSource:
          StatelessRulesAndCustomActions:
            StatelessRules:
              - RuleDefinition:
                  MatchAttributes:
                    Destinations:
                      - AddressDefinition: 127.0.0.1/32
                  Actions:
                    - 'aws:drop'
                Priority: !Ref RulegroupPriority


  # DynamoDB table that holds data about remediations taken, 
  # including IP addresses of suspicious hosts and timestamps of GuardDuty findings.
  # This data helps with periodic pruning to remove stale rules from AWS Network Firewall.
  GuardDutytoFirewallDDBTable:
    Type: "AWS::DynamoDB::Table"
    Properties:
      BillingMode: PAY_PER_REQUEST      
      AttributeDefinitions:
        -
          AttributeName: "HostIp"
          AttributeType: "S"
      KeySchema:
        -
          AttributeName: "HostIp"
          KeyType: "HASH"

  # SNS topic used for sending messages to admins
  GuardDutyToFirewallSNSTopic:
    Type: "AWS::SNS::Topic"
    Properties:
      Subscription:
        -
          Endpoint: !Ref AdminEmail
          Protocol: "email"

  # Lambda layer with boto3 version that supports network-firewall
  Boto3Layer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      CompatibleRuntimes:
        - python3.8
      Content:
        S3Bucket: !Ref ArtifactsBucket
        S3Key: !Sub ${ArtifactsPrefix}boto3_1.16.23_layer.zip
      Description: boto3 version 1.16.23
      LayerName: boto3

  
  ##########################################################################
  #                                                                        #
  # Blocking / Protection Section                                          #
  #                                                                        #
  ##########################################################################


  # state machine that orchestrates Lambda functions to block traffic and record 
  # data in the table, sends notifications on failure at any step or success
  # of the whole workflow
  GuardDutytoFirewallStateMachine:
    Type: "AWS::StepFunctions::StateMachine"
    Properties:
      RoleArn: !GetAtt 'GuardDutytoFirewallStateMachineExecutionRole.Arn'
      DefinitionString: !Sub |
        {
          "StartAt": "Record IP in DB",
          "Comment": "Triggered by GuardDuty finding, checks if remote IP is identified, then blocks traffic to that IP",
          "States": {
            "Record IP in DB": {
              "Type": "Task",
              "Resource": "${GuardDutytoFirewallRecordLambdaFunction.Arn}",
              "Parameters": {
                "comment": "Relevant fields from the GuardDuty / Security Hub finding",
                "HostIp.$": "$.detail.findings[0].ProductFields.aws/guardduty/service/action/networkConnectionAction/remoteIpDetails/ipAddressV4",
                "Timestamp.$": "$.detail.findings[0].ProductFields.aws/guardduty/service/eventLastSeen",
                "FindingId.$": "$.id",
                "AccountId.$": "$.account",
                "Region.$": "$.region"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "States.TaskFailed"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 2,
                  "BackoffRate": 2
                }
              ],
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Notify Failure"
                }
              ],
              "Next": "New IP?"
            },
            "New IP?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.NewIP",
                  "BooleanEquals": true,
                  "Next": "Block Traffic"
                }
              ],
              "Default": "No Firewall Change"
            },
            "No Firewall Change": {
              "Type": "Succeed"
            },
            "Block Traffic": {
              "Type": "Task",
              "Resource": "${GuardDutytoFirewallBlockLambdaFunction.Arn}",
              "Retry": [
                {
                  "ErrorEquals": [
                    "States.TaskFailed"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 2,
                  "BackoffRate": 2
                }
              ],
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Notify Failure"
                }
              ],
              "Next": "Notify Success"
            },
            "Notify Success": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Message": {
                  "Blocked": "true",
                  "Input.$": "$"
                },
                "TopicArn": "${GuardDutyToFirewallSNSTopic}"
              },
              "End": true
            },
            "Notify Failure": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Message": {
                  "Blocked": "false",
                  "Input.$": "$"
                },
                "TopicArn": "${GuardDutyToFirewallSNSTopic}"
              },
              "End": true
            }
          }
        }


  # permissions for state machine to invoke Lambda functions it's orchestrating
  # and to send notification messages to the SNS topic
  GuardDutytoFirewallStateMachineExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub states.${AWS::Region}.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: GuardDutytoFirewallStateMachineExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: 
                  - !GetAtt GuardDutytoFirewallBlockLambdaFunction.Arn
                  - !GetAtt GuardDutytoFirewallRecordLambdaFunction.Arn
              - Effect: Allow
                Action:
                - sns:Publish
                Resource: !Ref GuardDutyToFirewallSNSTopic


  # EventBridge Event Rule - For Security Hub event published to EventBridge:
  GuardDutytoFirewallStateMachineEvent:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "Security Hub - GuardDuty findings with remote IP"
      EventPattern:
        source:
        - aws.securityhub
        detail:
          findings:
            ProductFields:
              aws/guardduty/service/action/networkConnectionAction/remoteIpDetails/ipAddressV4:
                - "exists": true
      State: "ENABLED"
      Targets:
        -
          Arn: !GetAtt GuardDutytoFirewallStateMachine.Arn
          RoleArn: !GetAtt GuardDutytoFirewallStateMachineEventRole.Arn
          Id: "GuardDutyEvent-StepFunctions-Trigger"


  # permissions for EventBridge to invoke the state machine
  GuardDutytoFirewallStateMachineEventRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      Policies:               
        - PolicyName: GuardDutytoFirewallStateMachineStartExecution
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource:
                  - !GetAtt GuardDutytoFirewallStateMachine.Arn


  # Lambda function that blocks suspicious remote hosts
  # by updating a RuleGroup for the AWS Network Firewall 
  GuardDutytoFirewallBlockLambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      Role: !GetAtt [ GuardDutytoFirewallBlockLambdaExecutionRole, Arn ]
      Layers: 
        - !Ref Boto3Layer
      Runtime: python3.8
      Environment:
        Variables:
          FIREWALLRULEGROUP: !If [ CreateRulegroup, !Ref GuardDutytoFirewallRulegroup, !Sub 'arn:aws:network-firewall:${AWS::Region}:${AWS::AccountId}:stateless-rulegroup/${ExistingRuleGroup}']
          RULEGROUPPRI: !Ref  RulegroupPriority
      Timeout: 60
      Code:
        ZipFile: |
          import os, json, logging
          import boto3
          from botocore.exceptions import ClientError
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          #======================================================================================================================
          # Variables
          #======================================================================================================================
          RuleGroupArn = os.environ['FIREWALLRULEGROUP']
          RuleGroupPriority = os.environ['RULEGROUPPRI']
          #
          #
          #======================================================================================================================
          # Functions
          #======================================================================================================================
          #
          def create_sources(block_list):
              response = []
              for i in block_list:
                  response.append({'AddressDefinition': str(i['IP']) + '/32' })
              return response
          #
          def get_rg_config():
              client = boto3.client('network-firewall')
              response = client.describe_rule_group(
                  RuleGroupArn=RuleGroupArn,
                  Type='STATELESS'
              )
              return response
          #
          def update_rg_config(block_list):
              client = boto3.client('network-firewall')
              currgconfig = get_rg_config()
              RuleGroupPriorityDst = int(RuleGroupPriority) + 100
              #Create new rule from dictionary of IPs CIDRS to block
              newrules = [
                  {
                  'RuleDefinition': {
                      'MatchAttributes': {
                          'Sources': create_sources(block_list)
                      },
                      'Actions': [
                          'aws:drop',
                      ]
                  },
                  'Priority': int(RuleGroupPriority)
                  },
                  {
                  'RuleDefinition': {
                      'MatchAttributes': {
                          'Destinations': create_sources(block_list)
                      },
                      'Actions': [
                          'aws:drop',
                      ]
                  },
                  'Priority': int(RuleGroupPriorityDst)
                  }

              ]
              # Preserve current rules not used here in rule group by appending to new rule
              newrgconfig = currgconfig['RuleGroup']['RulesSource']['StatelessRulesAndCustomActions']['StatelessRules']
              try:
                for r in newrgconfig:
                    if int(r['Priority']) not in [ int(RuleGroupPriority), int(RuleGroupPriorityDst) ]:
                        newrules.append(r)
                #Update the rule group
                logger.info("Update Rule Group ARN, %s." % RuleGroupArn)
                response = client.update_rule_group(
                    UpdateToken=currgconfig['UpdateToken'],
                    RuleGroupArn=RuleGroupArn,
                    RuleGroup={
                        'RulesSource': {
                            'StatelessRulesAndCustomActions': {
                                'StatelessRules': 
                                    newrules,
                            }
                        }
                    },
                    Type='STATELESS',
                    Description='GD2NFW Blog Sample',
                    DryRun=False
                )
              except Exception as e:
                logger.error('something went wrong')
                raise  
          #
          #
          #======================================================================================================================
          # Lambda Entry Point
          #======================================================================================================================
          #
          # Lambda handler
          def handler(event, context):
              logger.info("log -- Event: %s " % json.dumps(event))
              # retrieve a list of IPs delivered from the previous step in the State Machine
              block_list = event['IPList']
              # update the AWS Network Firewall Rule Group
              # replace with the updated list of IPs
              update_rg_config(block_list)
              # pass the data on to the next step in the State Machine
              return { 
                  "HostIp": event['HostIp'],
                  "FindingId": event['FindingId'],
                  "Timestamp": event['Timestamp'],
                  "AccountId": event['AccountId'],
                  "Region": event['Region']
              }



  # Permissions for the Lambda function to interact with 
  # AWS Network Firewall service to update a RuleGroup
  GuardDutytoFirewallBlockLambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: GuardDutytoFirewallBlockLambdaPolicy 
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - network-firewall:DescribeRuleGroup
                  - network-firewall:UpdateRuleGroup
                Resource: !If [ CreateRulegroup, !Ref GuardDutytoFirewallRulegroup, !Sub 'arn:aws:network-firewall:${AWS::Region}:${AWS::AccountId}:stateless-rulegroup/${ExistingRuleGroup}']



  # records new entries in DynamoDB table, including IP addresses of suspicous hosts and timestamps
  # recording this data helps with pruning and removing of old entries
  GuardDutytoFirewallRecordLambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      Role: !GetAtt [ GuardDutytoFirewallRecordLambdaExecutionRole, Arn ]
      Runtime: python3.8
      Environment:
        Variables:
          ACLMETATABLE: !Ref GuardDutytoFirewallDDBTable
      Timeout: 60
      Code:
        ZipFile: |
          import json, os, boto3, logging
          import dateutil.parser
          from boto3.dynamodb.conditions import Key, Attr
          from botocore.exceptions import ClientError
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          #======================================================================================================================
          # Variables
          #======================================================================================================================
          ACLMETATABLE = os.environ['ACLMETATABLE']
          ddb = boto3.resource('dynamodb')
          table = ddb.Table(ACLMETATABLE)
          #======================================================================================================================
          # Functions
          #======================================================================================================================
          #
          # Converts from ISO 8601 to Unix Epoch time
          def convert_to_epoch(Timestamp):
              parsed_t = dateutil.parser.parse(Timestamp)
              t_in_seconds = parsed_t.strftime('%s')
              print (t_in_seconds)
              return (t_in_seconds)
          #
          # Creates a new DynamoDB item recording the IP, timestamp and other details
          def create_ddb_rule(record):
              ddb = boto3.resource('dynamodb')
              table = ddb.Table(ACLMETATABLE)
              response = table.put_item(
                  Item=record,
                  ReturnValues='ALL_OLD'
                  )
              if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                  if 'Attributes' in response:
                      logger.info("updated existing record, no new IP")
                      return False
                  else:
                      logger.info("log -- successfully added DDB state entry %s" % (record))
                      return True
              else:
                  logger.error("log -- error adding DDB state entry for %s" % (record))
                  logger.info(response)
                  raise
          #
          # gets all IPs in the DynamoDB table        
          def getAllIPs():
              Return_JSON = {}
              IPList = []
              try:
                  #scan the ddb table to find expired records
                  response = table.scan()
                  # if any records are found:
                  if response['Items']:
                      logger.info("log -- found records")
                      # process each expired record, append to list
                      for item in response['Items']:
                          logger.info("HostIp %s" %item['HostIp'])
                          IPList.append({"IP": item['HostIp']})
                  else:
                      logger.info("log -- no entries found.")
              except Exception as e:
                  logger.error('something went wrong')
                  raise  
              # respond with a list of all IPs in DynamoDB table
              return IPList 
          #
          #
          #======================================================================================================================
          # Lambda Entry Point
          #======================================================================================================================
          #
          # Lambda handler
          def handler(event, context):
              logger.info("log -- Event: %s " % json.dumps(event))
              # using epoch time (counted in seconds) to evaluate expiration
              epoch_time = convert_to_epoch(str(event['Timestamp']))
              # format a new record to be added to DynamoDB table
              record = {
                  'HostIp': str(event['HostIp']),
                  'Timestamp': str(event['Timestamp']),
                  'CreatedAt': int(epoch_time),
                  'FindingId': str(event['FindingId']),
                  'AccountId': str(event['AccountId']),
                  'Region': str(event['Region'])
                  }
              result = create_ddb_rule(record)
              if (result==True):
                  record['IPList'] = getAllIPs()
                  record['NewIP'] = True
              else:
                  record['NewIP'] = False
              # send data back to StepFunctions for the next step in the workflow
              return record


  # Permissions for Lambda function to update the DynamoDB table
  GuardDutytoFirewallRecordLambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: GuardDutytoFirewallRecordLambdaPolicy 
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                - "logs:CreateLogGroup"
                - "logs:CreateLogStream"
                - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                - dynamodb:GetItem
                - dynamodb:PutItem
                - dynamodb:Query
                - dynamodb:Scan
                - dynamodb:DeleteItem
                Resource: !GetAtt GuardDutytoFirewallDDBTable.Arn


  ##########################################################################
  ##########################################################################
  ##                                                                      ##
  ##  Pruning Section                                                     ##
  ##                                                                      ##
  ##########################################################################
  ##########################################################################  


  # periodic pruning of old firewall rules and table records
  PruningStateMachine:
    Type: "AWS::StepFunctions::StateMachine"
    Properties:
      RoleArn: !GetAtt 'PruningStateMachineExecutionRole.Arn'
      DefinitionString: !Sub |
        {
          "StartAt": "Get Expired Records from DynamoDB",
          "Comment": "Triggered by GuardDuty finding, checks if remote IP is identified, then blocks traffic to that IP",
          "States": {
            "Get Expired Records from DynamoDB": {
              "Type": "Task",
              "Resource": "${PruneGetExpiredIPsLambdaFunction.Arn}",
              "Retry": [
                {
                  "ErrorEquals": [
                    "States.TaskFailed"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 2,
                  "BackoffRate": 2
                }
              ],
              "Parameters": {
                "comment": "Retrieve expired records from the DynamoDB table"
              },
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Notify Failure to Get Expired IPs"
                }
              ],
              "Next": "Is Pruning Needed?"
            },
            "Is Pruning Needed?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.PruningNeeded",
                  "BooleanEquals": true,
                  "Next": "Remove Records from DynamoDB"
                }
              ],
              "Default": "No Pruning Needed"
            },
            "Remove Records from DynamoDB": {
              "Type": "Task",
              "Resource": "${PruneRecordsLambdaFunction.Arn}",
              "Retry": [
                {
                  "ErrorEquals": [
                    "States.TaskFailed"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 2,
                  "BackoffRate": 2
                }
              ],
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Notify Failure"
                }
              ],
              "Next": "Remove IPs from Firewall"
            },
            "Remove IPs from Firewall": {
              "Type": "Task",
              "Resource": "${PruneFirewallLambdaFunction.Arn}",
              "Parameters": {
                "IPList.$": "$.IPList",
                "comment": "Overwrites the RuleGrop with the updated list with expired IPs removed"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "States.TaskFailed"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 2,
                  "BackoffRate": 2
                }
              ],
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Notify Failure"
                }
              ],
              "Next": "Pruning Completed"
            },
            "Notify Failure": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Message": {
                  "Message": "Pruning Failed",
                  "Input.$": "$"
                },
                "TopicArn": "${GuardDutyToFirewallSNSTopic}"
              },
              "End": true
            },
            "Notify Failure to Get Expired IPs": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Message": {
                  "Message": "Pruning Failed - could not get expired IPs",
                  "Input.$": "$"
                },
                "TopicArn": "${GuardDutyToFirewallSNSTopic}"
              },
              "End": true
            },
            "Pruning Completed": {
              "Type": "Succeed"
            },
            "No Pruning Needed": {
              "Type": "Succeed"
            }
          }
        }


  # Scheduled trigger for pruning of AWS Network Firewall rules and DynamoDB records
  PruneOldEntriesSchedule:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "ScheduledPruningRule"
      ScheduleExpression: !Sub "rate(${PruningFrequency} minutes)"
      State: "ENABLED"
      Targets:
        -
          Arn: !GetAtt PruningStateMachine.Arn
          RoleArn: !GetAtt PruningStateMachineEventRole.Arn
          Id: "Pruning-StepFunctions-Schedule"


  # gives EventBridge permission to invoke the pruning state machine
  PruningStateMachineEventRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      Policies:               
        - PolicyName: PruningStateMachineStartExecution
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource:
                  - !GetAtt PruningStateMachine.Arn


  # permissions for the pruning state machine to invoke Lambda functions
  # and send messages to the SNS topic
  PruningStateMachineExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub states.${AWS::Region}.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: PruningStateMachineExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: 
                  - !GetAtt PruneGetExpiredIPsLambdaFunction.Arn
                  - !GetAtt PruneFirewallLambdaFunction.Arn
                  - !GetAtt PruneRecordsLambdaFunction.Arn
              - Effect: Allow
                Action:
                - sns:Publish
                Resource: !Ref GuardDutyToFirewallSNSTopic


  # Checks DynamoDB table for expired records that need to be pruned
  PruneGetExpiredIPsLambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      Role: !GetAtt [ PruneGetExpiredIPsLambdaExecutionRole, Arn ]
      Runtime: python3.8
      Environment:
        Variables:
          ACLMETATABLE: !Ref GuardDutytoFirewallDDBTable
          RETENTION: !Ref Retention
      Timeout: 60
      Code:
        ZipFile: |
          import os, boto3, logging, json, time
          from boto3.dynamodb.conditions import Key, Attr
          from botocore.exceptions import ClientError
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          #======================================================================================================================
          # Variables
          #======================================================================================================================
          ACLMETATABLE = os.environ['ACLMETATABLE']
          RETENTION = os.environ['RETENTION']
          ddb = boto3.resource('dynamodb')
          table = ddb.Table(ACLMETATABLE)
          #======================================================================================================================
          # Functions
          #======================================================================================================================
          #
          def getExpiredIPs(expire_time):
              Return_JSON = {}
              ExpiredIPList = []
              try:
                  #scan the ddb table to find expired records
                  response = table.scan(FilterExpression=Attr('CreatedAt').lt(expire_time))
                  # if expired records are found:
                  if response['Items']:
                      logger.info("log -- found expired entries, %s." % (response)['Items'])
                      Return_JSON['PruningNeeded'] = True
                      # process each expired record, append to list
                      for item in response['Items']:
                          logger.info("HostIp %s" %item['HostIp'])
                          ExpiredIPList.append({"IP": item['HostIp']})
                  else:
                      logger.info("log -- no entries older than %s minutes found." % (int(RETENTION)))
                      Return_JSON['PruningNeeded'] = False
              except Exception as e:
                  logger.error('something went wrong')
                  raise  
              # return nested JSON with a list of IPs
              Return_JSON['ExpiredIPList'] = ExpiredIPList
              return Return_JSON
          #======================================================================================================================
          # Lambda Entry Point
          #======================================================================================================================
          #
          # Lambda handler
          def handler(event, context):
            logger.info("log -- Event: %s " % json.dumps(event))
            # records older than this time stamp should be pruned
            expire_time = int(time.time()) - (int(RETENTION)*60)
            logger.info("log -- expire_time = %s" % expire_time)
            response = getExpiredIPs(expire_time)
            return response

  # permissions to remove old records from DynamoDB table
  PruneGetExpiredIPsLambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: PruneGetExpiredIPsLambdaPolicy 
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                - "logs:CreateLogGroup"
                - "logs:CreateLogStream"
                - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                - dynamodb:GetItem
                - dynamodb:Query
                - dynamodb:Scan
                Resource: !GetAtt GuardDutytoFirewallDDBTable.Arn



  # prunes old AWS Network Firewall records
  PruneFirewallLambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      Role: !GetAtt [ PruneFirewallLambdaExecutionRole, Arn ]
      Layers: 
        - !Ref Boto3Layer
      Environment:
        Variables:
          FIREWALLRULEGROUP: !If [ CreateRulegroup, !Ref GuardDutytoFirewallRulegroup, !Sub 'arn:aws:network-firewall:${AWS::Region}:${AWS::AccountId}:stateless-rulegroup/${ExistingRuleGroup}']
          RULEGROUPPRI: !Ref  RulegroupPriority
      Runtime: python3.8
      Timeout: 60
      Code:
        ZipFile: |
          import os, json, logging
          import boto3
          from botocore.exceptions import ClientError
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          #======================================================================================================================
          # Variables
          #======================================================================================================================
          RuleGroupArn = os.environ['FIREWALLRULEGROUP']
          RuleGroupPriority = os.environ['RULEGROUPPRI']
          #
          #
          #======================================================================================================================
          # Functions
          #======================================================================================================================
          #
          def create_sources(block_list):
              response = []
              for i in block_list:
                  response.append({'AddressDefinition': str(i['IP']) + '/32' })
              return response
          #
          def get_rg_config():
              client = boto3.client('network-firewall')
              response = client.describe_rule_group(
                  RuleGroupArn=RuleGroupArn,
                  Type='STATELESS'
              )
              return response
          #
          def update_rg_config(block_list):
              client = boto3.client('network-firewall')
              currgconfig = get_rg_config()
              RuleGroupPriorityDst = int(RuleGroupPriority) + 100
              #Create new rule from dictionary of IPs CIDRS to block
              newrules = [
                  {
                  'RuleDefinition': {
                      'MatchAttributes': {
                          'Sources': create_sources(block_list)
                      },
                      'Actions': [
                          'aws:drop',
                      ]
                  },
                  'Priority': int(RuleGroupPriority)
                  },
                  {
                  'RuleDefinition': {
                      'MatchAttributes': {
                          'Destinations': create_sources(block_list)
                      },
                      'Actions': [
                          'aws:drop',
                      ]
                  },
                  'Priority': int(RuleGroupPriorityDst)
                  }
              ]
              # Preserve current rules not used here in rule group by appending to new rule
              newrgconfig = currgconfig['RuleGroup']['RulesSource']['StatelessRulesAndCustomActions']['StatelessRules']
              try:
                for r in newrgconfig:
                    if int(r['Priority']) not in [ int(RuleGroupPriority), int(RuleGroupPriorityDst) ]:
                        newrules.append(r)
                #Update the rule group
                logger.info("Update Rule Group ARN, %s." % RuleGroupArn)
                response = client.update_rule_group(
                    UpdateToken=currgconfig['UpdateToken'],
                    RuleGroupArn=RuleGroupArn,
                    RuleGroup={
                        'RulesSource': {
                            'StatelessRulesAndCustomActions': {
                                'StatelessRules': 
                                    newrules,
                            }
                        }
                    },
                    Type='STATELESS',
                    Description='GD2NFW Blog Sample',
                    DryRun=False
                )
              except Exception as e:
                logger.error('something went wrong')
                raise  
          #
          #
          #======================================================================================================================
          # Lambda Entry Point
          #======================================================================================================================
          #
          # Lambda handler
          def handler(event, context):
              logger.info("log -- Event: %s " % json.dumps(event))
              # retrieve a list of IPs delivered from the previous step in the State Machine
              block_list = event['IPList']
              #if the list is empty, provide a loopback IP as a fake entry - rule group update requires at least one piece of data
              if len(block_list) == 0:
                  block_list = [{'IP':'127.0.0.1'}]
              # update the AWS Network Firewall Rule Group
              # replace with the updated list of IPs
              update_rg_config(block_list)
              # successful completion of the pruning process
              return { 
                  "PruningSuccessful": True
              }



  # provides permissions to interact with the AWS Network Firewall
  PruneFirewallLambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: PruneFirewallLambdaPolicy 
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - network-firewall:DescribeRuleGroup
                  - network-firewall:UpdateRuleGroup
                Resource: !If [ CreateRulegroup, !Ref GuardDutytoFirewallRulegroup, !Sub 'arn:aws:network-firewall:${AWS::Region}:${AWS::AccountId}:stateless-rulegroup/${ExistingRuleGroup}']


  # removes old records from the DynamoDB table
  PruneRecordsLambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      Role: !GetAtt [ PruneRecordsLambdaExecutionRole, Arn ]
      Runtime: python3.8
      Environment:
        Variables:
          ACLMETATABLE: !Ref GuardDutytoFirewallDDBTable
      Timeout: 60
      Code:
        ZipFile: |
          import os, boto3, logging, json
          from boto3.dynamodb.conditions import Key, Attr
          from botocore.exceptions import ClientError
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          #
          #======================================================================================================================
          # Variables
          #======================================================================================================================
          ACLMETATABLE = os.environ['ACLMETATABLE']
          ddb = boto3.resource('dynamodb')
          table = ddb.Table(ACLMETATABLE)
          #
          #======================================================================================================================
          # Functions
          #======================================================================================================================
          #
          # deletes all records matching the IP list
          def Delete_DynamoDB_Items(IPList):
              ddb = boto3.resource('dynamodb')
              table = ddb.Table(ACLMETATABLE)
              for IP in IPList:
                  response = table.delete_item(
                      Key={
                          'HostIp': IP['IP']
                          }
                      )
                  if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                      logger.info('log -- Delete_DynamoDB_Item successful')
                      return True
                  else:
                      logger.error('log -- Delete_DynamoDB_Item FAILED')
                      logger.info(response['ResponseMetadata'])
          #
          # gets all IPs in the DynamoDB table        
          def getAllIPs():
              IPList = []
              try:
                  #scan the ddb table to find expired records
                  response = table.scan()
                  # if any records are found:
                  if response['Items']:
                      logger.info("log -- found records")
                      # process each expired record, append to list
                      for item in response['Items']:
                          logger.info("HostIp %s" %item['HostIp'])
                          IPList.append({"IP": item['HostIp']})
                  else:
                      logger.info("log -- no entries found.")
              except Exception as e:
                  logger.error('something went wrong')
                  raise  
              # respond with a list of all IPs in DynamoDB table
              return IPList 
          #
          #======================================================================================================================
          # Lambda Entry Point
          #======================================================================================================================
          #
          # Lambda handler
          def handler(event, context):
              logger.info("log -- Event: %s " % json.dumps(event))
              # get the IP address to be removed from DynamoDB
              IPList = event['ExpiredIPList']
              logger.info("log -- removing IP addresses %s" % IPList)
              # delete expired IPs
              Delete_DynamoDB_Items(IPList)
              # retrieve IP addresses that need to be still in the rule group
              json_response = {}
              json_response['IPList'] = getAllIPs()
              return json_response



  # permissions to remove old records from DynamoDB table
  PruneRecordsLambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: PruneRecordsLambdaPolicy 
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                - "logs:CreateLogGroup"
                - "logs:CreateLogStream"
                - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                - dynamodb:GetItem
                - dynamodb:PutItem
                - dynamodb:Query
                - dynamodb:Scan
                - dynamodb:DeleteItem
                Resource: !GetAtt GuardDutytoFirewallDDBTable.Arn

      

Outputs:
  GuardDutytoFirewallStateMachine:
    Description: Step Functions State Machine orchestrating blocking of traffic and adding new rules to the AWS Network Firewall rule group
    Value: !Sub https://console.aws.amazon.com/states/home?region=${AWS::Region}#/statemachines/view/${GuardDutytoFirewallStateMachine}
  RuleGroupArn:
    Description: Stateless AWS Network Firewall Rule Group ARN that is managed by this solution
    Value: !If [ CreateRulegroup, !Ref GuardDutytoFirewallRulegroup, !Sub 'arn:aws:network-firewall:${AWS::Region}:${AWS::AccountId}:stateless-rulegroup/${ExistingRuleGroup}']